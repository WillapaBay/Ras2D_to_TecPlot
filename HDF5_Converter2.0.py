# -------------------------------------------------
# Version 3.0
# April 19, 2019
# Author: Elliot Steissberg, ERDC-EL
# Revised and refactored by Todd Steissberg, HEC
# -------------------------------------------------

"""
This program extracts velocity and bathymetry data from HEC-RAS 2D model output. It computes the
depths from the water surface elevation and bathymetry at each computation point in the TIN grid.
Before running this program, three files need to be generated by exporting the 2D flow areas via
RAS Mapper. Currently, it is necessary to run the model in "debug" mode to be able to access
the export option. The velocity vectors, water surface elevations, and bathymetry data are extracted
from the fort64.h5, fort63.h5, adn *.grd files, respectively. The time stamps are extracted from
the main HEC-RAS project output HDF5 file.
"""

import os
import h5py
import numpy as np
import matplotlib

matplotlib.use('agg')
import matplotlib.pyplot as plt
from scipy import interpolate


def quiverPlot(X, Y, U, V, timeStamp, scale):
    figure, axis = plt.subplots()
    axis.set_title(timeStamp)
    plt.axis('equal')
    M = np.hypot(U, V)
    Q = axis.quiver(X, Y, U, V, M, units='xy', scale=scale)  # Other keywords: pivot='tip', width=1
    quiverKey = axis.quiverkey(Q, 0.9, 0.9, 1, r'$1 \frac{m}{s}$', labelpos='E',
                               coordinates='figure')


def createOutputFilename(outputPath, projectFilename, timeStamp, fileExtension, customLabel=""):
    pathParts = os.path.splitext(projectFilename)[0].split("/")
    baseFilename = pathParts[-1]
    timeLabel = parseDate(timeStamp).replace("/", "_").replace(" ", "_").replace(":", "")
    if customLabel != "":
        outputFilename = "%s/%s_%s_%s.%s" % (outputPath, baseFilename, timeLabel, customLabel, fileExtension)
    else:
        outputFilename = "%s/%s_%s.%s" % (outputPath, baseFilename, timeLabel, fileExtension)
    return outputFilename


def parseDate(timeString):
    """Parse a time string from the project HDF5 output file.
    Note: This does not handle the time strings in the ADCIRC HDF5 files."""
    months = {"JAN": 1, "FEB": 2, "MAR": 3, "APR": 4, "MAY": 5, "JUN": 6,
              "JUL": 7, "AUG": 8, "SEP": 9, "OCT": 10, "NOV": 11, "DEC": 12}

    monthStr = "undefined"
    dayStr = "undefined"
    yearStr = "undefined"

    dateStr, timeStr = str(timeString).split(" ")

    for i in months.keys():
        if i in dateStr:
            monthStr = months[i]
            dayStr = dateStr.split(i)[0]
            yearStr = dateStr.split(i)[1]

    # Create output date-time string
    # Only keep hour and minute from time string
    hourMinuteStr = ":".join(timeStr.split(":")[0:2])
    dateTime = "%s/%s/%s %s" % (dayStr, monthStr, yearStr, hourMinuteStr)
    return dateTime


class Ras2D:
    """Extract 2D velocity and bathymetry data from the RAS-2D output files,
    including the HDF5 and TIN ASCII grid files exported via RAS Mapper. Compute
    depths from the water surface elevation and the bathymetry data."""

    def __init__(self, projectFilename, fort63Filename, fort64Filename, tinFilename, outputPath):
        self.projectFilename = projectFilename
        self.fort63Filename = fort63Filename
        self.fort64Filename = fort64Filename
        self.tinFilename = tinFilename
        self.outputPath = outputPath
        self.velocitiesPath = "Datasets/Depth-averaged Velocity (64)/Values"
        self.timesPath = "Results/Unsteady/Output/Output Blocks/Base Output/Unsteady Time Series/Time Date Stamp"
        self.waterSurfaceElevationsPath = "Datasets/Water Surface Elevation (63)/Values"

        """The data dictionary will contain the following keys:
        Times:                  Time stamp of each output time step
        X:                      East-West (X) coordinate of ground surface at the nodes
        Y:                      North-South (Y) coordinate of ground surface at the nodes
        Z:                      Elevation of the ground surface at the nodes
        U:                      East-West velocity component at the nodes
        V:                      North-South velocity component at the nodes
        WaterSurfaceElevations: Water surface elevation at the nodes
        Depths:                 Depths at the nodes
        """
        self.data = {}

        # Open input files
        self.projectFile = h5py.File(projectFilename, "r")
        self.fort63File = h5py.File(fort63Filename, "r")
        self.fort64File = h5py.File(fort64Filename, "r")
        self.tinFile = open(tinFilename, "r")

        # Velocities
        velocities = self.fort64File[self.velocitiesPath]
        self.data["U"] = [list(np.transpose(velocities[i])[0]) for i in range(len(velocities))]
        self.data["V"] = [list(np.transpose(velocities[i])[1]) for i in range(len(velocities))]

        # Time
        timesBinary = list(self.projectFile[self.timesPath])
        timesAscii = list(map(lambda t: t.decode("ASCII"), timesBinary))
        self.data["Times"] = timesAscii

        # Elevation of ground surface
        self.data["WaterSurfaceElevations"] = list(self.fort63File[self.waterSurfaceElevationsPath])

        # Assemble a list of x, y, z coordinates and depths at the nodes
        tinLines = self.tinFile.readlines()
        numPoints = int(tinLines[1].strip().split("\t")[1])
        dataLines = tinLines[2:(numPoints + 2)]
        xList = []
        yList = []
        zList = []
        nodeList = []
        for line in dataLines:
            data = line.strip().split("\t")
            node, x, y = data[0].split(" ")
            z = data[1]
            x, y, z = list(map(float, [x, y, z]))
            nodeList.append(int(node))
            xList.append(x)
            yList.append(y)
            zList.append(z)

        self.data["Nodes"] = np.array(nodeList)
        self.data["X"] = np.array(xList)
        self.data["Y"] = np.array(yList)
        self.data["Z"] = np.array(zList)

        # Create the calculated depth array for each time step
        waterDepthsList = []
        # Iterate over time steps
        for i in range(len(self.data["WaterSurfaceElevations"])):
            groundElevation = self.data["Z"][i]
            waterDepths = []
            for waterSurfaceElevation in self.data["WaterSurfaceElevations"][i]:
                if waterSurfaceElevation > -999.0 and groundElevation > -999.0:
                    depth = waterSurfaceElevation - groundElevation
                    waterDepths.append(depth)
                else:
                    waterDepths.append(0.0)
            waterDepthsList.append(waterDepths)
        self.data["Depths"] = waterDepthsList

        # Compute mean depth
        self.meanDepth = np.mean(np.transpose(self.data["Depths"])[0])

    def plotVelocities(self, scale=1.0, fileExtension="png"):
        """Plot velocity vectors for each time step and save each plot to an image file"""
        for timeStamp in self.data["Times"]:
            outputFilename = createOutputFilename(self.outputPath, self.projectFilename, timeStamp,
                                                  fileExtension, customLabel="velocities")
            timeIndex = self.data["Times"].index(timeStamp)
            Ut = np.array(self.data["U"][timeIndex])
            Vt = np.array(self.data["V"][timeIndex])
            print("Saving plot to %s" % outputFilename)
            quiverPlot(self.data["X"], self.data["Y"], Ut, Vt, timeStamp, scale)
            plt.savefig(outputFilename)
            plt.close()

    def plotDepths(self, fileExtension="png", xmin=0.0, xmax=10000.0, dx=4.0,
                   ymin=0.0, ymax=10000.0, dy=4.0, zmin=0.0, zmax=100.0, dz=1.0):
        """Plot depths for each time step and save each plot to an image file"""

        # Prepare uniform interpolation grid
        xi = np.linspace(xmin, xmax, int(dx))
        yi = np.linspace(ymin, ymax, int(dy))
        Xi, Yi = np.meshgrid(xi, yi)

        for timeStamp in self.data["Times"]:
            outputFilename = createOutputFilename(self.outputPath, self.projectFilename, timeStamp,
                                                  fileExtension, customLabel="depths")
            timeIndex = self.data["Times"].index(timeStamp)
            Zt = np.array(self.data["Depths"][timeIndex])

            # Interpolate to grid
            interpToGrid = interpolate.interp2d(self.data["X"], self.data["Y"], Zt, kind='cubic')
            Zi = interpToGrid(xi, yi)

            # Plot depths
            print("Saving plot to %s" % outputFilename)
            figure, axis = plt.subplots()
            axis.set_title(timeStamp)
            plt.axis('equal')
            axis.pcolor(Xi, Yi, Zi)
            plt.savefig(outputFilename)
            plt.close()

    def writeToAscii(self, header, dataFormatString, fileExtension):
        """Create an output file for each time step in TecPlot format
        from the dictionary created by getValues"""
        for timeStamp in self.data["Times"]:
            outputFilename = createOutputFilename(self.outputPath, self.projectFilename,
                                                  timeStamp, fileExtension)
            timeIndex = self.data["Times"].index(timeStamp)
            outputFile = open(outputFilename, "w")
            lines = [header]
            for i in range(len(self.data["X"])):
                x = self.data["X"][i]
                y = self.data["Y"][i]
                z = self.data["Z"][i]
                u = self.data["U"][timeIndex][i]
                v = self.data["V"][timeIndex][i]
                depth = self.data["Depths"][timeIndex][i]
                lines.append(dataFormatString % (x, y, z, u, v, depth))
            print("Writing to %s" % outputFilename)
            outputFile.write("\n".join(lines))
            outputFile.close()

    def writeToCsv(self):
        """Create an output file for each time step in comma-delimited format
        from the dictionary created by getValues"""
        header = "X,Y,Z,U,V,Depth"
        dataFormatString = "%f,%f,%f,%f,%f,%f"
        self.writeToAscii(header, dataFormatString, "csv")

    def writeToTecPlot(self):
        """Create an output file for each time step in TecPlot format
        from the dictionary created by getValues"""
        header = 'VARIABLES = "X" "Y" "Z" "U" "V" "DEPTH"'
        dataFormatString = "%f %f %f %f %f %f"
        self.writeToAscii(header, dataFormatString, "dat")


if __name__ == "__main__":
    # Muncie model
    # Enter full paths to project HDF5 output file and ADCIRC files generated by RasMapper
    projectFilename = "C:/Users/q0hectes/Documents/IdeaProjects/HDF5utilityForDaveSmith/src/Muncie.p04.hdf"
    fort63Filename = "C:/Users/q0hectes/Documents/IdeaProjects/HDF5utilityForDaveSmith/src/fort63.h5"
    fort64Filename = "C:/Users/q0hectes/Documents/IdeaProjects/HDF5utilityForDaveSmith/src/fort64.h5"
    tinFilename = "C:/Users/q0hectes/Documents/IdeaProjects/HDF5utilityForDaveSmith/src/2D interior Area_TIN.grd"
    outputPath = "C:/Users/q0hectes/Documents/IdeaProjects/HDF5utilityForDaveSmith/src"
    vectorScale = 0.01

    muncie = Ras2D(projectFilename, fort63Filename, fort64Filename, tinFilename, outputPath)
    print(muncie.meanDepth)
    muncie.writeToTecPlot()
    muncie.plotVelocities(scale=vectorScale)
    # muncie.plotDepths(fileExtension="png", xmin=404000.0, xmax=413000.0, dx=100.0, ymin=1800000.0,
    # ymax=1806000.0, dy=100.0, zmin=-10.0, zmax=20.0, dz=1.0)

    # Clearwater model
    projectFilename = "F:/HDF_utility_for_Dave_Smith/ModelForTesting/HEC-RAS/SF_Clearwater.p01.hdf"
    fort63Filename = "F:/HDF_utility_for_Dave_Smith/ModelForTesting/HEC-RAS/P1/fort63.h5"
    fort64Filename = "F:/HDF_utility_for_Dave_Smith/ModelForTesting/HEC-RAS/P1/fort64.h5"
    tinFilename = "F:/HDF_utility_for_Dave_Smith/ModelForTesting/HEC-RAS/P1/2D domain_TIN.grd"
    outputPath = "F:/HDF_utility_for_Dave_Smith/ModelForTesting/HEC-RAS/P1"
    vectorScale = 0.1

    clearwater = Ras2D(projectFilename, fort63Filename, fort64Filename, tinFilename, outputPath)
    print(clearwater.meanDepth)
    clearwater.writeToTecPlot()
    clearwater.plotVelocities(scale=vectorScale)
